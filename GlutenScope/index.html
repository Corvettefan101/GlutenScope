<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GlutenScope</title>
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="https://i.imgur.com/T5LqpmZ.png">
    <!-- Tailwind CSS CDN for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font for sleek typography -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Leaflet CSS for OpenStreetMap integration -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
    <style>
        /* Base body styling with Inter font and light background */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #e0e0e0; /* Lighter background to complement logo */
        }
        /* Styling for the restaurant map container */
        #map {
            height: 400px; /* Fixed height for consistency */
            width: 100%;
            border-radius: 0.75rem; /* Rounded corners */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* Subtle shadow */
        }
        /* Styling for the stores map container (separate for potential future differentiation) */
        #map-stores {
            height: 400px;
            width: 100%;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        /* Custom scrollbar for the results container for better UX */
        .scrollable-results::-webkit-scrollbar {
            width: 8px;
        }
        .scrollable-results::-webkit-scrollbar-track {
            background: #e0e0e0;
            border-radius: 10px;
        }
        .scrollable-results::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .scrollable-results::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        /* Style for the favorite star icon */
        .favorite-star {
            cursor: pointer;
            font-size: 1.5rem; /* Adjust size as needed */
            color: #ccc; /* Default color (unfavorited) */
            transition: color 0.2s ease-in-out;
        }
        .favorite-star.favorited {
            color: #EAB308; /* Gold color for favorited */
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 sm:p-6 md:p-8">

    <!-- Login/Signup Section (initially shown, hidden on successful auth) -->
    <div id="auth-section" class="bg-white rounded-xl shadow-lg p-6 sm:p-8 md:p-10 w-full max-w-md flex flex-col gap-6 items-center">
        <img src="https://i.imgur.com/5lIWduz.png" alt="GlutenScope Logo" class="w-40 h-40 mb-4 rounded-full shadow-md" onerror="this.onerror=null;this.src='https://placehold.co/128x128/cccccc/333333?text=Logo';">
        <h2 class="text-3xl font-bold text-[#2D6A4F] mb-4 whitespace-nowrap">Welcome to GlutenScope</h2>
        <p class="text-gray-600 mb-6 text-center">Sign up or log in to manage your gluten-free favorites!</p>

        <input type="email" id="auth-email" placeholder="Email"
               class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#2D6A4F] focus:border-transparent transition duration-200 ease-in-out shadow-sm">
        <input type="password" id="auth-password" placeholder="Password"
               class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#2D6A4F] focus:border-transparent transition duration-200 ease-in-out shadow-sm">

        <button id="signup-button"
                class="w-full bg-[#2D6A4F] text-white px-6 py-3 rounded-lg shadow-md hover:bg-[#3E8B6A] focus:outline-none focus:ring-2 focus:ring-[#2D6A4F] focus:ring-offset-2 transition duration-200 ease-in-out font-semibold">
            Sign Up
        </button>
        <button id="login-button"
                class="w-full bg-gray-200 text-gray-800 px-6 py-3 rounded-lg shadow-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 transition duration-200 ease-in-out font-semibold">
            Login
        </button>
    </div>

    <!-- Main Application Section (initially hidden, shown on successful auth) -->
    <div id="app-section" class="hidden bg-white rounded-xl shadow-lg p-6 sm:p-8 md:p-10 w-full max-w-4xl flex flex-col gap-6">

        <!-- Header Section: App title and tagline with logo and logout -->
        <header class="text-center mb-4 relative"> <!-- Added relative for absolute positioning of logout button -->
            <div class="flex flex-col items-center"> <!-- Centered logo and tagline -->
                <img src="https://i.imgur.com/5lIWduz.png" alt="GlutenScope Logo" class="w-24 h-24 rounded-full shadow-md" onerror="this.onerror=null;this.src='https://placehold.co/128x128/cccccc/333333?text=Logo';">
                <p class="text-lg text-gray-600 mt-2">Your guide to a gluten-free lifestyle.</p>
            </div>
            <button id="logout-button"
                    class="absolute top-4 right-4 bg-red-600 text-white px-4 py-2 rounded-lg shadow-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 transition duration-200 ease-in-out font-semibold">
                Logout
            </button>
        </header>

        <!-- Search Bar Section: Input field and search button -->
        <div class="flex flex-col sm:flex-row gap-3">
            <input type="text" id="search-input" placeholder="Search for restaurants, recipes, or stores..."
                   class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#2D6A4F] focus:border-transparent transition duration-200 ease-in-out shadow-sm">
            <button id="search-button"
                    class="bg-[#2D6A4F] text-white px-6 py-3 rounded-lg shadow-md hover:bg-[#3E8B6A] focus:outline-none focus:ring-2 focus:ring-[#2D6A4F] focus:ring-offset-2 transition duration-200 ease-in-out font-semibold">
                Search
            </button>
        </div>

        <!-- Tab Navigation: Buttons to switch between content types -->
        <div class="flex justify-center gap-2 sm:gap-4 bg-gray-100 p-2 rounded-lg shadow-inner">
            <!-- Initial state: Only Restaurants tab is active. Others are inactive. -->
            <button id="tab-restaurants" class="tab-button px-4 py-2 rounded-md bg-[#2D6A4F] text-white shadow-md font-medium hover:bg-[#3E8B6A] transition duration-200 ease-in-out" data-tab="restaurants" data-active="true">Restaurants</button>
            <button id="tab-recipes" class="tab-button px-4 py-2 rounded-md text-gray-700 font-medium hover:bg-[#3E8B6A] hover:text-white transition duration-200 ease-in-out" data-tab="recipes" data-active="false">Recipes</button>
            <button id="tab-stores" class="tab-button px-4 py-2 rounded-md text-gray-700 font-medium hover:bg-[#3E8B6A] hover:text-white transition duration-200 ease-in-out" data-tab="stores" data-active="false">Stores</button>
            <button id="tab-favorites" class="tab-button px-4 py-2 rounded-md text-gray-700 font-medium hover:bg-[#3E8B6A] hover:text-white transition duration-200 ease-in-out" data-tab="favorites" data-active="false">Favorites</button>
        </div>

        <!-- Content Area: Holds map and search results, dynamically shown/hidden by tabs -->
        <div id="content-area" class="flex flex-col gap-6">

            <!-- Map Section for Restaurants -->
            <div id="map-section" class="tab-content" data-tab="restaurants" data-active="true">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Restaurants on Map</h2>
                <div id="map"></div>
            </div>
            <!-- Map Section for Stores (initially hidden) -->
            <div id="map-section-stores" class="tab-content hidden" data-tab="stores" data-active="false">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Stores on Map</h2>
                <div id="map-stores"></div>
            </div>
            <!-- Favorites Section (initially hidden) -->
            <div id="favorites-section" class="tab-content hidden" data-tab="favorites" data-active="false">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Your Favorite Items</h2>
                <div id="favorites-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 scrollable-results max-h-[500px] overflow-y-auto p-2">
                    <p id="no-favorites-message" class="text-gray-500 text-center col-span-full">
                        You haven't favorited any items yet. Start exploring!
                    </p>
                </div>
            </div>

            <!-- Results Section: Displays search results as cards -->
            <div id="results-section">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Search Results</h2>
                <div id="results-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 scrollable-results max-h-[500px] overflow-y-auto p-2">
                    <!-- Results will be dynamically loaded here by JavaScript -->
                    <p id="no-results-message" class="text-gray-500 text-center col-span-full">
                        Allow location access or use the search bar to find gluten-free options!
                    </p>
                </div>
            </div>

        </div>

        <!-- Loading Indicator: Shown during API calls -->
        <div id="loading-indicator" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white p-6 rounded-lg shadow-lg flex flex-col items-center">
                <div class="animate-spin rounded-full h-12 w-12 border-4 border-t-4 border-[#2D6A4F] border-opacity-25"></div>
                <p class="mt-4 text-gray-700 font-medium">Loading...</p>
            </div>
        </div>

        <!-- Custom Message Box: Replaces alert() for better UX -->
        <div id="message-box" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white p-6 rounded-lg shadow-lg max-w-sm w-full text-center">
                <h3 id="message-title" class="text-xl font-semibold text-gray-800 mb-3"></h3>
                <p id="message-content" class="text-gray-600 mb-5"></p>
                <button id="message-close-button" class="bg-[#2D6A4F] text-white px-6 py-3 rounded-lg shadow-md hover:bg-[#3E8B6A] focus:outline-none focus:ring-2 focus:ring-[#2D6A4F] focus:ring-offset-2 transition duration-200 ease-in-out font-semibold">
                    OK
                </button>
            </div>
        </div>

    </div>

    <!-- Leaflet JavaScript Library for interactive maps -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Supabase Client Library -->
    <script type="module">
        import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm';

        // --- Supabase Configuration ---
        const SUPABASE_URL = 'https://ekklphylwwembloqcwvl.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVra2xwaHlsd3dlbWJsb3Fjd3ZsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE2NjQ0MTIsImV4cCI6MjA2NzI0MDQxMn0.HmpxTolcj0MiKCqIG3gaM6mz4hmcNAp27Ss1eD6pZw4';
        const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- DOM Element References ---
        const authSection = document.getElementById('auth-section');
        const appSection = document.getElementById('app-section');
        const authEmailInput = document.getElementById('auth-email');
        const authPasswordInput = document.getElementById('auth-password');
        const signupButton = document.getElementById('signup-button');
        const loginButton = document.getElementById('login-button');
        const logoutButton = document.getElementById('logout-button');

        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-button');
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        const resultsSection = document.getElementById('results-section'); // Get the whole section
        const resultsContainer = document.getElementById('results-container');
        const noResultsMessage = document.getElementById('no-results-message');
        const favoritesContainer = document.getElementById('favorites-container');
        const noFavoritesMessage = document.getElementById('no-favorites-message');
        const loadingIndicator = document.getElementById('loading-indicator');
        const messageBox = document.getElementById('message-box');
        const messageTitle = document.getElementById('message-title');
        const messageContent = document.getElementById('message-content');
        const messageCloseButton = document.getElementById('message-close-button');

        // --- Application State Variables ---
        let currentActiveTab = 'restaurants'; // Default active tab
        let userLatitude = null;
        let userLongitude = null;
        let mapRestaurant = null; // Leaflet map instance for restaurants
        let mapStore = null;    // Leaflet map instance for stores
        let restaurantMarkers = L.featureGroup(); // Layer group for restaurant markers
        let storeMarkers = L.featureGroup();      // Layer group for store markers
        let userFavorites = []; // Array to store current user's favorites

        // --- Custom Leaflet Icons for Map Pins ---
        // Define a custom icon for restaurants
        const restaurantIcon = L.divIcon({
            className: 'custom-restaurant-pin',
            html: '<div class="bg-[#2D6A4F] w-6 h-6 rounded-full flex items-center justify-center shadow-md">' +
                  '<div class="bg-[#EAB308] w-2 h-2 rounded-full"></div>' + // Gold dot for wheat
                  '</div>',
            iconSize: [24, 24], // size of the icon
            iconAnchor: [12, 24], // point of the icon which will correspond to marker's location
            popupAnchor: [0, -24] // point from which the popup should open relative to the iconAnchor
        });

        // Define a custom icon for stores (using the same design for consistency)
        const storeIcon = L.divIcon({
            className: 'custom-store-pin',
            html: '<div class="bg-[#2D6A4F] w-6 h-6 rounded-full flex items-center justify-center shadow-md">' +
                  '<div class="bg-[#EAB308] w-2 h-2 rounded-full"></div>' + // Gold dot for wheat
                  '</div>',
            iconSize: [24, 24],
            iconAnchor: [12, 24],
            popupAnchor: [0, -24]
        });

        /**
         * Displays a custom modal message box to the user.
         * @param {string} title - The title of the message.
         * @param {string} content - The content of the message.
         */
        function showMessage(title, content) {
            messageTitle.textContent = title;
            messageContent.textContent = content;
            messageBox.classList.remove('hidden');
        }

        /**
         * Hides the custom modal message box.
         */
        function hideMessage() {
            messageBox.classList.add('hidden');
        }

        /**
         * Shows the global loading indicator.
         */
        function showLoading() {
            loadingIndicator.classList.remove('hidden');
        }

        /**
         * Hides the global loading indicator.
         */
        function hideLoading() {
            loadingIndicator.classList.add('hidden');
        }

        /**
         * Initializes or re-initializes the Leaflet map for restaurants.
         * Ensures only one map instance exists for the 'map' div.
         */
        function initializeRestaurantMap() {
            if (mapRestaurant) {
                mapRestaurant.remove(); // Clean up existing map instance to prevent duplicates
            }
            mapRestaurant = L.map('map').setView([0, 0], 2); // Default view (global)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(mapRestaurant);
            restaurantMarkers.addTo(mapRestaurant); // Add marker layer to the map
        }

        /**
         * Initializes or re-initializes the Leaflet map for stores.
         * Ensures only one map instance exists for the 'map-stores' div.
         */
        function initializeStoreMap() {
            if (mapStore) {
                mapStore.remove(); // Clean up existing map instance
            }
            mapStore = L.map('map-stores').setView([0, 0], 2); // Default view (global)
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(mapStore);
            storeMarkers.addTo(mapStore); // Add marker layer to the map
        }

        /**
         * Prompts the user for their geolocation and returns their coordinates.
         * Handles permission denied or unsupported browser scenarios.
         * @returns {Promise<{latitude: number, longitude: number}>} A promise that resolves with user's coordinates.
         */
        function getUserLocation() {
            return new Promise((resolve, reject) => {
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(
                        (position) => {
                            userLatitude = position.coords.latitude;
                            userLongitude = position.coords.longitude;
                            console.log("Geolocation: User location obtained:", userLatitude, userLongitude);
                            resolve({ latitude: userLatitude, longitude: userLongitude });
                        },
                        (error) => {
                            console.error("Geolocation Error:", error);
                            let errorMessage = "Unable to retrieve your location. Please use the search bar.";
                            if (error.code === error.PERMISSION_DENIED) {
                                errorMessage = "Location access denied. Please enable location services in your browser settings to find nearby places, or use the search bar.";
                            }
                            showMessage('Location Access Required', errorMessage);
                            reject(new Error(errorMessage));
                        },
                        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 } // Geolocation options
                    );
                } else {
                    const errorMessage = "Geolocation is not supported by your browser. Please use the search bar.";
                    showMessage('Browser Limitation', errorMessage);
                    reject(new Error(errorMessage));
                }
            });
        }

        /**
         * Generates a simple unique ID for an item based on its name, address, and type.
         * This is used as `item_id` in Supabase to prevent duplicate favorites.
         * @param {object} item - The item object (restaurant, recipe, or store).
         * @param {string} type - The type of item.
         * @returns {string} A unique ID string.
         */
        function generateItemId(item, type) {
            if (type === 'recipes') {
                return `recipe-${item.title.replace(/\s/g, '_').toLowerCase().substring(0, 50)}`;
            }
            return `${type}-${(item.name || '').replace(/\s/g, '_').toLowerCase().substring(0, 50)}-${(item.address || '').replace(/\s/g, '_').toLowerCase().substring(0, 50)}`;
        }

        /**
         * Toggles an item's favorite status in Supabase.
         * @param {object} item - The item to favorite/unfavorite.
         * @param {string} type - The type of item ('restaurant', 'recipe', 'store').
         * @param {HTMLElement} starElement - The star icon element to update.
         */
        async function toggleFavorite(item, type, starElement) {
            const { data: { user } } = await supabase.auth.getUser(); // Destructure to get user directly
            if (!user) { // Now this check is more accurate
                showMessage('Authentication Required', 'Please log in to add items to your favorites.');
                return;
            }

            const itemId = generateItemId(item, type);
            const isFavorited = userFavorites.some(fav => fav.item_id === itemId);

            showLoading();
            try {
                if (isFavorited) {
                    // Remove from favorites
                    const { error } = await supabase
                        .from('favorites')
                        .delete()
                        .eq('user_id', user.id) // Use user.id directly
                        .eq('item_id', itemId);

                    if (error) throw error;
                    userFavorites = userFavorites.filter(fav => fav.item_id !== itemId);
                    starElement.classList.remove('favorited');
                    starElement.textContent = '☆'; // Update star icon
                    showMessage('Success', 'Removed from favorites!');
                } else {
                    // Add to favorites
                    const { error } = await supabase
                        .from('favorites')
                        .insert({
                            user_id: user.id, // Use user.id directly
                            item_id: itemId,
                            item_type: type,
                            item_data: item
                        });

                    if (error) throw error;
                    userFavorites.push({ user_id: user.id, item_id: itemId, item_type: type, item_data: item });
                    starElement.classList.add('favorited');
                    starElement.textContent = '★'; // Update star icon
                    showMessage('Success', 'Added to favorites!');
                }
                // If currently on the favorites tab, re-render it
                if (currentActiveTab === 'favorites') {
                    renderFavorites();
                }
            } catch (error) {
                console.error("Error toggling favorite:", error);
                showMessage('Error', `Failed to update favorites: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        /**
         * Fetches current user's favorites from Supabase.
         */
        async function fetchUserFavorites() {
            const { data: { user } } = await supabase.auth.getUser(); // Destructure to get user directly
            if (!user) { // Now this check is more accurate
                userFavorites = []; // Clear favorites if no user
                return;
            }

            showLoading();
            try {
                const { data, error } = await supabase
                    .from('favorites')
                    .select('*')
                    .eq('user_id', user.id); // Use user.id directly

                if (error) throw error;
                userFavorites = data || [];
                console.log("Fetched favorites:", userFavorites);
            } catch (error) {
                console.error("Error fetching favorites:", error);
                showMessage('Error', `Failed to load favorites: ${error.message}`);
                userFavorites = []; // Ensure favorites are cleared on error
            } finally {
                hideLoading();
            }
        }

        /**
         * Renders the search results into the results container as interactive cards.
         * Also places markers on the appropriate map for location-based results.
         * @param {Array} results - The array of result objects (restaurants, recipes, or stores).
         * @param {string} type - The type of results ('restaurants', 'recipes', 'stores').
         * @param {HTMLElement} container - The HTML element to render results into.
         * @param {HTMLElement} noResultsMsgElement - The HTML element for no results message.
         */
        function renderResults(results, type, container, noResultsMsgElement) {
            container.innerHTML = ''; // Clear previous results
            noResultsMsgElement.classList.add('hidden'); // Hide the no results message initially

            // If no results, display a message and return
            if (!results || results.length === 0) {
                noResultsMsgElement.textContent = `No ${type.replace('-', ' ')} found. Try a different search query!`;
                noResultsMsgElement.classList.remove('hidden');
                // Ensure maps are cleared if no results are found
                if (type === 'restaurants') {
                    restaurantMarkers.clearLayers();
                    if (userLatitude && userLongitude) mapRestaurant.setView([userLatitude, userLongitude], 13);
                } else if (type === 'stores') {
                    storeMarkers.clearLayers();
                    if (userLatitude && userLongitude) mapStore.setView([userLatitude, userLongitude], 13);
                }
                return;
            }

            // Clear existing map markers before adding new ones
            if (type === 'restaurants') {
                restaurantMarkers.clearLayers();
            } else if (type === 'stores') {
                storeMarkers.clearLayers();
            }

            // Iterate through results and create a card for each
            results.forEach(item => {
                const card = document.createElement('div');
                card.className = 'bg-white rounded-lg shadow-md p-4 flex flex-col gap-2 border border-gray-200 hover:shadow-lg transition duration-200 ease-in-out';

                const itemId = generateItemId(item, type);
                const isFavorited = userFavorites.some(fav => fav.item_id === itemId);
                const starClass = isFavorited ? 'favorited' : '';
                const starIcon = isFavorited ? '★' : '☆'; // Filled star vs. empty star

                // Handle different card layouts based on result type
                if (type === 'restaurants' || type === 'stores') {
                    const name = item.name || 'Unknown Place';
                    const address = item.address || 'Address not available';
                    const phoneNumber = item.phoneNumber || ''; // Get phone number
                    const description = item.description || '';
                    const url = item.url;
                    const latitude = parseFloat(item.latitude);
                    const longitude = parseFloat(item.longitude);

                    // Construct Google Maps URL for directions
                    let directionsUrl = '';
                    if (userLatitude && userLongitude && !isNaN(latitude) && !isNaN(longitude)) {
                        directionsUrl = `https://www.google.com/maps/dir/${userLatitude},${userLongitude}/${latitude},${longitude}`;
                    } else if (!isNaN(latitude) && !isNaN(longitude)) {
                        directionsUrl = `https://www.google.com/maps/dir/?api=1&destination=${latitude},${longitude}&travelmode=driving`;
                    } else if (address) {
                        directionsUrl = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(address)}&travelmode=driving`;
                    }

                    card.innerHTML = `
                        <div class="flex justify-between items-start">
                            <h3 class="text-xl font-semibold text-[#2D6A4F]">${name}</h3>
                            <span class="favorite-star ${starClass}" data-item-id="${itemId}" data-item-type="${type}">${starIcon}</span>
                        </div>
                        <p class="text-gray-600 text-sm">${address}</p>
                        ${phoneNumber ? `<p class="text-gray-700 text-sm">Phone: <a href="tel:${phoneNumber}" class="text-[#2D6A4F] hover:underline">${phoneNumber}</a></p>` : ''}
                        ${description ? `<p class="text-gray-700 mt-2 text-sm">${description}</p>` : ''}
                        <div class="flex flex-wrap gap-2 mt-2">
                            ${url ? `<a href="${url}" target="_blank" class="text-[#2D6A4F] hover:underline text-sm font-medium" rel="noopener noreferrer">Visit Website</a>` : ''}
                            ${directionsUrl ? `<a href="${directionsUrl}" target="_blank" class="text-[#2D6A4F] hover:underline text-sm font-medium" rel="noopener noreferrer">Get Directions</a>` : ''}
                        </div>
                    `;

                    // Add marker to the map if valid coordinates are provided
                    if (!isNaN(latitude) && !isNaN(longitude)) {
                        const marker = L.marker([latitude, longitude], { icon: (type === 'restaurants' ? restaurantIcon : storeIcon) }).bindPopup(
                            `<b>${name}</b><br>${address}` +
                            `${phoneNumber ? `<br>Phone: <a href="tel:${phoneNumber}">${phoneNumber}</a>` : ''}`
                        );
                        if (type === 'restaurants') {
                            restaurantMarkers.addLayer(marker);
                        } else if (type === 'stores') {
                            storeMarkers.addLayer(marker);
                        }
                    }

                } else if (type === 'recipes') {
                    const title = item.title || 'Untitled Recipe';
                    // Format ingredients as an unordered list
                    const ingredients = item.ingredients && Array.isArray(item.ingredients)
                        ? item.ingredients.map(ing => `<li>${ing}</li>`).join('')
                        : 'No ingredients listed.';
                    const instructions = item.instructions || 'No instructions available.';
                    const url = item.url;

                    card.innerHTML = `
                        <div class="flex justify-between items-start">
                            <h3 class="text-xl font-semibold text-[#2D6A4F]">${title}</h3>
                            <span class="favorite-star ${starClass}" data-item-id="${itemId}" data-item-type="${type}">${starIcon}</span>
                        </div>
                        <div class="mt-2 text-gray-700 text-sm">
                            <p class="font-medium">Ingredients:</p>
                            <ul class="list-disc list-inside ml-2">${ingredients}</ul>
                        </div>
                        <div class="mt-2 text-gray-700 text-sm">
                            <p class="font-medium">Instructions:</p>
                            <p>${instructions}</p>
                        </div>
                        ${url ? `<a href="${url}" target="_blank" class="text-[#2D6A4F] hover:underline text-sm mt-2" rel="noopener noreferrer">View Recipe</a>` : ''}
                    `;
                }
                container.appendChild(card); // Add the created card to the results container

                // Attach event listener to the star button
                const starElement = card.querySelector('.favorite-star');
                if (starElement) {
                    starElement.addEventListener('click', () => toggleFavorite(item, type, starElement));
                }
            });

            // Adjust map view to fit all markers or center on user if no markers
            if (type === 'restaurants' && restaurantMarkers.getLayers().length > 0) {
                mapRestaurant.fitBounds(restaurantMarkers.getBounds(), { padding: [50, 50] });
            } else if (type === 'stores' && storeMarkers.getLayers().length > 0) {
                mapStore.fitBounds(storeMarkers.getBounds(), { padding: [50, 50] });
            } else if (type === 'restaurants' && userLatitude && userLongitude) {
                mapRestaurant.setView([userLatitude, userLongitude], 13); // Center on user if no results found for current area
            } else if (type === 'stores' && userLatitude && userLongitude) {
                mapStore.setView([userLatitude, userLongitude], 13); // Center on user if no results found for current area
            }
        }

        /**
         * Renders the user's favorite items in the favorites container.
         * This function is specifically for the favorites tab and does not include
         * the "Search Results" heading.
         */
        function renderFavorites() {
            favoritesContainer.innerHTML = ''; // Clear previous favorites
            noFavoritesMessage.classList.add('hidden'); // Hide the no favorites message initially

            if (!userFavorites || userFavorites.length === 0) {
                noFavoritesMessage.textContent = "You haven't favorited any items yet. Start exploring!";
                noFavoritesMessage.classList.remove('hidden');
                return;
            }

            userFavorites.forEach(fav => {
                const item = fav.item_data;
                const type = fav.item_type;

                const card = document.createElement('div');
                card.className = 'bg-white rounded-lg shadow-md p-4 flex flex-col gap-2 border border-gray-200 hover:shadow-lg transition duration-200 ease-in-out';

                const itemId = generateItemId(item, type);
                const isFavorited = userFavorites.some(f => f.item_id === itemId); // Should always be true here
                const starClass = isFavorited ? 'favorited' : '';
                const starIcon = isFavorited ? '★' : '☆';

                if (type === 'restaurants' || type === 'stores') {
                    const name = item.name || 'Unknown Place';
                    const address = item.address || 'Address not available';
                    const phoneNumber = item.phoneNumber || '';
                    const description = item.description || '';
                    const url = item.url;
                    const latitude = parseFloat(item.latitude);
                    const longitude = parseFloat(item.longitude);

                    let directionsUrl = '';
                    if (userLatitude && userLongitude && !isNaN(latitude) && !isNaN(longitude)) {
                        directionsUrl = `https://www.google.com/maps/dir/${userLatitude},${userLongitude}/${latitude},${longitude}`;
                    } else if (!isNaN(latitude) && !isNaN(longitude)) {
                        directionsUrl = `https://www.google.com/maps/dir/?api=1&destination=${latitude},${longitude}&travelmode=driving`;
                    } else if (address) {
                        directionsUrl = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(address)}&travelmode=driving`;
                    }

                    card.innerHTML = `
                        <div class="flex justify-between items-start">
                            <h3 class="text-xl font-semibold text-[#2D6A4F]">${name}</h3>
                            <span class="favorite-star ${starClass}" data-item-id="${itemId}" data-item-type="${type}">${starIcon}</span>
                        </div>
                        <p class="text-gray-600 text-sm">${address}</p>
                        ${phoneNumber ? `<p class="text-gray-700 text-sm">Phone: <a href="tel:${phoneNumber}" class="text-[#2D6A4F] hover:underline">${phoneNumber}</a></p>` : ''}
                        ${description ? `<p class="text-gray-700 mt-2 text-sm">${description}</p>` : ''}
                        <div class="flex flex-wrap gap-2 mt-2">
                            ${url ? `<a href="${url}" target="_blank" class="text-[#2D6A4F] hover:underline text-sm font-medium" rel="noopener noreferrer">Visit Website</a>` : ''}
                            ${directionsUrl ? `<a href="${directionsUrl}" target="_blank" class="text-[#2D6A4F] hover:underline text-sm font-medium" rel="noopener noreferrer">Get Directions</a>` : ''}
                        </div>
                    `;
                } else if (type === 'recipes') {
                    const title = item.title || 'Untitled Recipe';
                    const ingredients = item.ingredients && Array.isArray(item.ingredients)
                        ? item.ingredients.map(ing => `<li>${ing}</li>`).join('')
                        : 'No ingredients listed.';
                    const instructions = item.instructions || 'No instructions available.';
                    const url = item.url;

                    card.innerHTML = `
                        <div class="flex justify-between items-start">
                            <h3 class="text-xl font-semibold text-[#2D6A4F]">${title}</h3>
                            <span class="favorite-star ${starClass}" data-item-id="${itemId}" data-item-type="${type}">${starIcon}</span>
                        </div>
                        <div class="mt-2 text-gray-700 text-sm">
                            <p class="font-medium">Ingredients:</p>
                            <ul class="list-disc list-inside ml-2">${ingredients}</ul>
                        </div>
                        <div class="mt-2 text-gray-700 text-sm">
                            <p class="font-medium">Instructions:</p>
                            <p>${instructions}</p>
                        </div>
                        ${url ? `<a href="${url}" target="_blank" class="text-[#2D6A4F] hover:underline text-sm mt-2" rel="noopener noreferrer">View Recipe</a>` : ''}
                    `;
                }
                favoritesContainer.appendChild(card);

                const starElement = card.querySelector('.favorite-star');
                if (starElement) {
                    starElement.addEventListener('click', () => toggleFavorite(item, type, starElement));
                }
            });
        }


        /**
         * Makes a call to the Gemini API (via your secure backend proxy) with a structured prompt and a defined JSON schema.
         * Handles loading states and potential API errors.
         * @param {string} promptText - The user's query or instruction for the LLM.
         * @param {object} responseSchema - The JSON schema defining the expected structure of the LLM's response.
         * @returns {Promise<Array>} A promise that resolves with the parsed JSON results, or an empty array on error.
         */
        async function callGeminiAPI(promptText, responseSchema) {
            showLoading(); // Show loading indicator
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: promptText }] });

            const payload = {
                prompt: promptText, // Send the prompt directly
                responseSchema: responseSchema // Send the schema
            };

            // This URL is now correctly set for Cloudflare Pages Functions
            const backendApiUrl = '/gemini-proxy'; // Relative path for Cloudflare Pages Functions

            try {
                const response = await fetch(backendApiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                // Check for HTTP errors (e.g., 4xx or 5xx status codes)
                if (!response.ok) {
                    const errorBody = await response.text();
                    throw new Error(`Backend API call failed with status ${response.status}: ${errorBody}`);
                }

                // The Cloudflare Pages function is designed to return the direct result from Gemini
                // which should be the `candidates[0].content.parts[0].text` as JSON.
                // So, we can directly return the result after parsing the response body.
                const result = await response.json(); // This will parse the JSON from the Cloudflare function
                console.log("Gemini API raw result (via backend):", result);
                return result; // Assuming your backend returns the parsed JSON directly

            } catch (error) {
                console.error("Error calling backend API:", error);
                showMessage('API Error', `Failed to fetch data: ${error.message}. Please try again.`);
                return []; // Return empty array on any error
            } finally {
                hideLoading();
            }
        }

        /**
         * Main function to handle search operations based on the active tab and user input/location.
         * Constructs the appropriate prompt and schema for the Gemini API call.
         */
        async function handleSearch() {
            const query = searchInput.value.trim(); // Get trimmed search query

            // Validate input for location-based searches if no query and no user location
            if (!query && (currentActiveTab === 'restaurants' || currentActiveTab === 'stores') && !userLatitude) {
                showMessage('Input Required', 'Please enter a search query or allow location access to find nearby places.');
                return;
            }

            let promptText = '';
            let schema = {};

            // Define prompt and schema based on the active tab
            if (currentActiveTab === 'restaurants') {
                schema = {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "name": { "type": "STRING" },
                            "address": { "type": "STRING" },
                            "latitude": { "type": "NUMBER" },
                            "longitude": { "type": "NUMBER" },
                            "phoneNumber": { "type": "STRING" },
                            "description": { "type": "STRING" },
                            "url": { "type": "STRING" }
                        },
                        required: ["name", "address", "latitude", "longitude"]
                    }
                };
                if (query) {
                    promptText = `Find all gluten-free restaurants within 10 miles of "${query}". Provide their name, address, latitude, longitude, phone number, a brief description, and a website URL if available. Ensure all found locations are provided with accurate coordinates for map display.`;
                } else if (userLatitude && userLongitude) {
                    promptText = `Find all gluten-free restaurants within 10 miles of latitude ${userLatitude}, longitude ${userLongitude}. Provide their name, address, latitude, longitude, phone number, a brief description, and a website URL if available. Ensure all found locations are provided with accurate coordinates for map display.`;
                }
                const restaurants = await callGeminiAPI(promptText, schema);
                resultsSection.classList.remove('hidden'); // Show search results section
                renderResults(restaurants, 'restaurants', resultsContainer, noResultsMessage);
                // Invalidate map size to ensure it renders correctly after content is visible
                if (restaurants.length > 0) {
                    mapRestaurant.invalidateSize();
                }
            } else if (currentActiveTab === 'recipes') {
                if (!query) {
                    showMessage('Input Required', 'Please enter a keyword to search for recipes.');
                    return;
                }
                schema = {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "title": { "type": "STRING" },
                            "ingredients": {
                                "type": "ARRAY",
                                "items": { "type": "STRING" }
                            },
                            "instructions": { "type": "STRING" },
                            "url": { "type": "STRING" }
                        },
                        required: ["title", "ingredients", "instructions"]
                    }
                };
                promptText = `Find gluten-free recipes for "${query}". Provide the recipe title, a list of ingredients, detailed instructions, and a URL to the recipe if available.`;
                const recipes = await callGeminiAPI(promptText, schema);
                resultsSection.classList.remove('hidden'); // Show search results section
                renderResults(recipes, 'recipes', resultsContainer, noResultsMessage);
            } else if (currentActiveTab === 'stores') {
                if (!query) {
                    showMessage('Input Required', 'Please enter a keyword to search for stores.');
                    return;
                }
                schema = {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "name": { "type": "STRING" },
                            "address": { "type": "STRING" },
                            "latitude": { "type": "NUMBER" },
                            "longitude": { "type": "NUMBER" },
                            "phoneNumber": { "type": "STRING" },
                            "description": { "type": "STRING" },
                            "url": { "type": "STRING" }
                        },
                        required: ["name", "address", "latitude", "longitude"]
                    }
                };
                if (query) {
                    promptText = `Find all gluten-free stores or grocery stores with confirmed gluten-free options within 10 miles of "${query}". Provide their name, address, latitude, longitude, phone number, a brief description, and a website URL if available. Ensure all found locations are provided with accurate coordinates for map display.`;
                } else if (userLatitude && userLongitude) {
                    promptText = `Find all gluten-free stores or grocery stores with confirmed gluten-free options within 10 miles of latitude ${userLatitude}, longitude ${userLongitude}. Provide their name, address, latitude, longitude, phone number, a brief description, and a website URL if available.`;
                }
                const stores = await callGeminiAPI(promptText, schema);
                resultsSection.classList.remove('hidden'); // Show search results section
                renderResults(stores, 'stores', resultsContainer, noResultsMessage);
                // Invalidate map size for stores map
                if (stores.length > 0) {
                    mapStore.invalidateSize();
                }
            }
        }

        // --- Authentication Functions ---
        async function handleSignUp() {
            const email = authEmailInput.value;
            const password = authPasswordInput.value;
            showLoading();
            try {
                const { data, error } = await supabase.auth.signUp({ email, password });
                if (error) throw error;
                showMessage('Sign Up Successful', 'Please check your email to confirm your account, then log in.');
                authEmailInput.value = '';
                authPasswordInput.value = '';
            } catch (error) {
                console.error("Sign Up Error:", error);
                showMessage('Sign Up Failed', error.message);
            } finally {
                hideLoading();
            }
        }

        async function handleLogin() {
            const email = authEmailInput.value;
            const password = authPasswordInput.value;
            showLoading();
            try {
                const { data, error } = await supabase.auth.signInWithPassword({ email, password });
                if (error) throw error;
                showMessage('Login Successful', `Welcome back, ${data.user.email}!`);
                authEmailInput.value = '';
                authPasswordInput.value = '';
                // Auth state change listener will handle UI update
            } catch (error) {
                console.error("Login Error:", error);
                showMessage('Login Failed', error.message);
            } finally {
                hideLoading();
            }
        }

        async function handleLogout() {
            showLoading();
            try {
                const { error } = await supabase.auth.signOut();
                if (error) throw error;
                showMessage('Logged Out', 'You have been successfully logged out.');
                // Auth state change listener will handle UI update
            } catch (error) {
                console.error("Logout Error:", error);
                showMessage('Logout Failed', error.message);
            } finally {
                hideLoading();
            }
        }

        /**
         * Updates the UI based on authentication status.
         * @param {object|null} session - The Supabase session object or null if logged out.
         */
        async function updateUI(session) {
            if (session) {
                authSection.classList.add('hidden');
                appSection.classList.remove('hidden');
                await fetchUserFavorites(); // Fetch favorites for the logged-in user

                // Trigger initial search for restaurants or favorites if favorites tab is active
                if (currentActiveTab === 'favorites') {
                    resultsSection.classList.add('hidden'); // Hide search results section
                    renderFavorites();
                } else {
                    resultsSection.classList.remove('hidden'); // Show search results section
                    await getUserLocation();
                    if (userLatitude && userLongitude) {
                        await handleSearch();
                    }
                }
            } else {
                authSection.classList.remove('hidden');
                appSection.classList.add('hidden');
                userFavorites = []; // Clear favorites when logged out
                // Clear search results and maps when logged out
                resultsContainer.innerHTML = '';
                favoritesContainer.innerHTML = '';
                noResultsMessage.textContent = 'Allow location access or use the search bar to find gluten-free options!';
                noResultsMessage.classList.remove('hidden');
                noFavoritesMessage.textContent = "You haven't favorited any items yet. Start exploring!";
                noFavoritesMessage.classList.remove('hidden');
                restaurantMarkers.clearLayers();
                storeMarkers.clearLayers();
                resultsSection.classList.add('hidden'); // Hide search results section when logged out
            }
        }

        // --- Event Listeners ---

        // Close button for the custom message box
        messageCloseButton.addEventListener('click', hideMessage);

        // Auth button handlers
        signupButton.addEventListener('click', handleSignUp);
        loginButton.addEventListener('click', handleLogin);
        logoutButton.addEventListener('click', handleLogout);

        // Search button click handler
        searchButton.addEventListener('click', handleSearch);

        // Allow pressing Enter key in the search input to trigger search
        searchInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleSearch();
                }
            });

        // Event listeners for tab buttons to switch content
        tabButtons.forEach(button => {
            button.addEventListener('click', async () => {
                // Deactivate all tab buttons by removing active classes and setting data-active to false
                tabButtons.forEach(btn => {
                    btn.setAttribute('data-active', 'false');
                    btn.classList.remove('bg-[#2D6A4F]', 'text-white', 'shadow-md');
                    btn.classList.add('text-gray-700'); // Add back default text color
                });
                // Activate the clicked button
                button.setAttribute('data-active', 'true');
                button.classList.add('bg-[#2D6A4F]', 'text-white', 'shadow-md');
                button.classList.remove('text-gray-700'); // Remove default text color

                // Hide all tab content sections and show the relevant one
                currentActiveTab = button.dataset.tab;
                tabContents.forEach(content => {
                    if (content.dataset.tab === currentActiveTab) {
                        content.classList.remove('hidden');
                        content.setAttribute('data-active', 'true');
                        // Crucial: Invalidate map size when its tab becomes visible
                        if (currentActiveTab === 'restaurants' && mapRestaurant) {
                            mapRestaurant.invalidateSize();
                        } else if (currentActiveTab === 'stores' && mapStore) {
                            mapStore.invalidateSize();
                        }
                    } else {
                        content.classList.add('hidden');
                        content.setAttribute('data-active', 'false');
                    }
                });

                // Handle visibility of the search results section
                if (currentActiveTab === 'favorites') {
                    resultsSection.classList.add('hidden'); // Hide search results section for favorites tab
                } else {
                    resultsSection.classList.remove('hidden'); // Show search results section for other tabs
                    // Clear previous search results when switching tabs, unless it's the favorites tab
                    resultsContainer.innerHTML = '';
                    noResultsMessage.textContent = 'Start by searching or allow location access to find nearby gluten-free options!';
                    noResultsMessage.classList.remove('hidden');
                    searchInput.value = '';
                }


                // Handle specific tab actions
                if (currentActiveTab === 'restaurants') {
                    try {
                        await getUserLocation();
                        if (userLatitude && userLongitude) {
                            await handleSearch();
                        }
                    } catch (error) {
                        console.warn("Geolocation for restaurants failed or denied:", error);
                    }
                } else if (currentActiveTab === 'stores') {
                    try {
                        await getUserLocation();
                        if (userLatitude && userLongitude) {
                            await handleSearch();
                        }
                    } catch (error) {
                        console.warn("Geolocation for stores failed or denied:", error);
                    }
                }
                else if (currentActiveTab === 'favorites') {
                    renderFavorites(); // Display favorites directly
                }
            });
        });

        // --- Initial Application Setup on Window Load ---
        window.onload = async function () {
            // Initialize both maps on load (only one will be visible at a time)
            initializeRestaurantMap();
            initializeStoreMap();

            // Set initial active tab styling for Restaurants
            const initialRestaurantTab = document.getElementById('tab-restaurants');
            initialRestaurantTab.classList.add('bg-[#2D6A4F]', 'text-white', 'shadow-md');
            initialRestaurantTab.classList.remove('text-gray-700');

            // Listen for auth state changes from Supabase
            supabase.auth.onAuthStateChange((event, session) => {
                console.log("Auth state changed:", event, session);
                updateUI(session);
            });

            // Initial check for session on load
            const { data: { session } = {} } = await supabase.auth.getSession(); // Destructure with default empty object
            updateUI(session);

            // If already authenticated and not on favorites tab, try to get location and search
            if (session && currentActiveTab !== 'favorites') {
                try {
                    await getUserLocation();
                    if (userLatitude && userLongitude) {
                        await handleSearch();
                    }
                } catch (error) {
                    console.warn("Initial location fetch failed for authenticated user:", error);
                }
            }
        };
    </script>
</body>
</html>
